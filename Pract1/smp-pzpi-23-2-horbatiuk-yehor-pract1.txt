МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ

Звіт

з практичної роботи №1
з дисципліни
«Скриптові мови програмування»


Виконав:                                                                                              Перевірив:
ст. гр. ПЗПІ-23-2                                                                                 Ст. викл.                                                                                                             
Горбатюк Єгор                                                                                    Сокорчук І.П.                                    












Харків – 2025
ЗАВДАННЯ

Написатати Bash скрипт, який друкуватиме на екрані ялинку із
двох ярусів гілок, стовбура та шару снігу.
ХІД РОБОТИ

Створимо скрипт вказуємо оболонку:

1  #!/bin/bash

Спочатку зазначаємо інтерпретатор — у цьому випадку Bash. Це необхідно, щоб при запуску скрипт працював у середовищі саме bash, який підтримує всі використовувані конструкції (від арифметичних виразів до вкладених умовних операторів та циклів).

Оголошуємо допоміжну функцію для центрованого виведення рядка:

2  print_centered_line() {
3    local total_width=$1
4    local line_chars="$2"
5    local line_len=$3
6    local padding=$(( (total_width - line_len) / 2 ))
7    printf "%*s" "$padding" ""
8    printf "%s\n" "$line_chars"
9  }

Тут `print_centered_line` приймає три аргументи:
- `total_width` (загальна ширина доступного простору, по ширині «снігу», над яким ми малюватимемо рядок),
- `line_chars` (рядок символів, який потрібно відобразити: сукупність `*` чи `#`, що формують частину крони або стовбура),
- `line_len` (довжина цього рядка символів, тобто кількість `*` або `#`).

У тілі функції спочатку обчислюємо `padding` — відступ ліворуч таким чином, щоб загальна ширина відступу плюс ширина рядка символів складала `total_width`. Для цього беремо різницю `(total_width - line_len)` і ділимо навпіл — перша частина буде для відступу, а інша частина (еквівалентна `line_len`) займе сам рядок символів. Потім за допомогою `printf "%*s"` друкуємо необхідну кількість пробілів, після чого виводимо самі символи. Завдяки цьому кожен рядок буде вирівняний по центру щодо заданої ширини `snow_width`.

Далі — перевірка кількості аргументів:

10  if [[ $# -ne 2 ]]; then
11    echo "Використання: $0 <висота> <ширина_снігу>" >&2
12    exit 1
13  fi

За допомогою `[[ $# -ne 2 ]]` перевіряємо, що саме два аргументи були передані скрипту: перший — це висота майбутньої ялинки (загальна кількість рядків, що формують гілки та стовбур разом зі снігом), другий — ширина підставки зі снігу. Якщо аргументів не два, виводимо повідомлення про правильний синтаксис виклику й завершуємо скрипт з кодом помилки `1`.

Зберігаємо параметри в змінні:

14  height=$1
15  snow_width=$2

Тут `$1` та `$2` — перший і другий аргументи командного рядка. Змінна `height` задає кількість рядків для крони та стовбура, а `snow_width` визначає ширину останнього рядка «снігу», який ми обов’язково малюватимемо, щоб підкреслити основу дерева.

Перевірка, чи параметри — додатні цілі числа:

16  if (( height <= 0 || snow_width <= 0 )); then
17    echo "Аргументи мають бути додатніми цілими числами!" >&2
18    exit 1
19  fi

Використовуємо арифметичну перевірку `(( ... ))`, щоб упевнитися, що обидві змінні більше нуля. Якщо хоча б одна з них не додатна, виводимо повідомлення про помилку в стандартний потік помилок (`>&2`) і завершуємося з кодом `1`.

Задаємо фіксовані значення для висоти та ширини стовбура і снігової основи:

20  trunk_height=2
21  trunk_width=3
22  snow_height=1

Стовбур будемо малювати завжди з двох рядків, кожен з трьох символів `#`. Тому `trunk_height`=2, `trunk_width`=3. Щоб унизу дерева намалювати єдиний рядок снігу, задаємо `snow_height`=1 (з однієї низької «підкладки» з `*` по всій ширині). Ці значення статичні, тобто не залежать від параметра `height` чи `snow_width`, окрім того, що враховуються в обчисленнях висоти гілок.

Також потрібно знати, скільки рядків піде на гілки: від усього `height` віднімаємо висоту стовбура (`trunk_height`) та снігу (`snow_height`):

23  branches_total=$(( height - trunk_height - snow_height ))
24  if (( branches_total < 1 )); then
25    echo "Висота ($height) надто мала: має бути щонайменше 3 (гілки + стовбур + сніг)." >&2
26    exit 2
27  fi

В ідеальному випадку для зображення ялинки нам потрібно принаймні один рядок для крони, два — для стовбура і один — для снігу. Якщо `branches_total` (кількість рядків, що залишилися для гілок) менше 1, значить загальної висоти недостатньо — виводимо відповідну помилку з кодом `2` (індикатор того, що саме висота виявилась занадто малою).

Розбиваємо гілки на два яруси:

28  first_tier_height=$(( (branches_total + 1) / 2 ))
29  second_tier_height=$(( branches_total / 2 ))

Щоб крона виглядала поступово ширшою вниз, ми ділимо гілки на два яруси. Якщо, наприклад, `branches_total` = 5, тоді перший ярус матиме `(5 + 1) / 2 = 3` рядки, а другий — `5 / 2 = 2` рядки. Це дає більш природну форму конусу. У випадку, коли `branches_total` парне, наприклад 4, обидва яруси матимуть по 2 рядки.

У цьому місці ми обчислюємо, скільки рядків присвятити кожному «ярусу» крони ялинки, тому що загальна кількість рядків (branches_total) ділиться на два приблизно рівні блоки, причому у випадку непарної кількості рядків перший ярус буде більшим на один рядок. Це забезпечує поступове розширення «гілок» у напрямку донизу, де кожен наступний рядок збільшує ширину на два символи, а також дозволяє застосувати чергування символів для візуального ефекту (зірочки й решітки), після чого по завершенню ярусів іде безпосереднє малювання стовбура ялинки з фіксованою шириною та висотою, а в кінці додається шар «снігу», що займає всю задану ширину snow_width, щоб створити відчуття підставки під ялинкою.

Малюємо перший ярус гілок (починаємо з ширини 1):

30  width=1
31  for ((i = 1; i <= first_tier_height; i++)); do
32    if (( i % 2 == 1 )); then
33      line_chars=$(printf '%*s' "$width" | tr ' ' '*')
34    else
35      line_chars=$(printf '%*s' "$width" | tr ' ' '#')
36    fi
37    print_centered_line "$snow_width" "$line_chars" "$width"
38    width=$(( width + 2 ))
39  done

Пояснення:
- Змінна `width` відповідає за поточну ширину «гілочок» у символах. Для першого рядка вона дорівнює `1`, потім росте на 2 з кожним кроком, тому виглядає як 1, 3, 5, 7… — класична форма конусу з кроком 2.
- У циклі `for ((i = 1; i <= first_tier_height; i++))` проходимо по всіх рядках першого ярусу.
- Якщо номер рядка `i` непарний (`i % 2 == 1`), формуємо рядок з `width` символів `*`: `printf '%*s' "$width" | tr ' ' '*'`. У протилежному випадку — із символів `#`.
- Далі викликаємо `print_centered_line`, передаючи загальну ширину снігу `snow_width`, сформований рядок символів і його довжину `width`. Функція сама розмістить рядок по центру.
- Після виведення кожного рядка збільшуємо `width` на 2, щоб наступний рядок був ширшим.

Таким чином виходить плавне нарощування крони з чергуванням символів для візуальної різноманітності.

Малюємо другий ярус (починаємо з ширини 3):

40  width=3
41  for ((j = 1; j <= second_tier_height; j++)); do
42    if (( j % 2 == 1 )); then
43      line_chars=$(printf '%*s' "$width" | tr ' ' '#')
44    else
45      line_chars=$(printf '%*s' "$width" | tr ' ' '*')
46    fi
47    print_centered_line "$snow_width" "$line_chars" "$width"
48    width=$(( width + 2 ))
49  done

Особливості:
- У другому ярусі стартуємо з `width=3`, щоб відразу показати поступовий перехід від верхнього ярусу, який зупинився на ширині останнього рядка першого ярусу (це було `1 + 2*(first_tier_height-1)`).
- Логіка чергування символів міняється: у випадках, коли `j` (рядок другого ярусу) непарний, виводимо `#`, а коли парний — `*`. Таким чином утворюється своєрідний «переплетений» візерунок.
- Функція центрованого виведення гарантує, що кожен рядок другого ярусу теж буде по центру підснігової ширини.

Малюємо стовбур (дві строки з символами "#"):

50  for ((t = 0; t < 2; t++)); do
51    print_centered_line "$snow_width" "###" "$trunk_width"
52  done

Тут фіксуємо виведення двох рядків (`trunk_height=2`) із трьох символів “#” (`trunk_width=3`), відцентрованих під загальною шириною `snow_width`. У результаті утворюється «стовбур» дерева, що своєю консистенцією та шириною відрізняється від гілок — це дозволяє візуально відокремити основу ялинки від крони.

Малюємо нижній сніговий рядок:

53  snow_line=$(printf '%*s' "$snow_width" | tr ' ' '*')
54  print_centered_line "$snow_width" "$snow_line" "$snow_width"

Тут:
- Команда `printf '%*s' "$snow_width"` створює рядок із `$snow_width` пробілів. Далі `tr ' ' '*'` замінює всі пробіли на зірочки, отримуючи суцільний рядок `*` завширшки `$snow_width`.
- Викликаємо `print_centered_line` із передачею цих самих параметрів — оскільки ширина рядка (`line_len`) і `snow_width` збігаються, `padding` стане нульовим, і рядок виведеться без відступу. Це завершує малювання, створюючи підніжжя «снігу», що ніби підкреслює деревце і робить його завершеним.




ВИСНОВКИ

У результаті отримано працюючий Bash-скрипт, який відповідає поставленому завданню: за двома аргументами (висота дерева та ширина основи) він генерує новорічної ялинки з чітко розмежованими ярусами крони, стовбуром та шаром снігу, що демонструє знання базових конструкцій Bash, вмінь роботи з рядками та форматованого виведення. Посилання на відеозвіт: https://youtu.be/EBLqARq8IzI



ДОДАТОК А
Відеозвіт
Посилання на відеозвіт: https://youtu.be/EBLqARq8IzI


 
ДОДАТОК Б
Програмний код

1  #!/bin/bash  
2  
3  print_centered_line() {  
4    local total_width=$1  
5    local line_chars="$2"  
6    local line_len=$3  
7    local padding=$(( (total_width - line_len) / 2 ))  
8    printf "%*s" "$padding" ""  
9    printf "%s\n" "$line_chars"  
10 }  
11  
12 if [[ $# -ne 2 ]]; then  
13   echo "Використання: $0 <висота> <ширина_снігу>" >&2  
14   exit 1  
15 fi  
16  
17 height=$1  
18 snow_width=$2  
19  
20 if (( height <= 0 || snow_width <= 0 )); then  
21   echo "Аргументи мають бути додатніми цілими числами!" >&2  
22   exit 1  
23 fi  
24  
25 trunk_height=2  
26 trunk_width=3  
27 snow_height=1  
28  
29 branches_total=$(( height - trunk_height - snow_height ))  
30 if (( branches_total < 1 )); then  
31   echo "Висота ($height) надто мала: має бути щонайменше 3 (гілки + стовбур + сніг)." >&2  
32   exit 2  
33 fi  
34  
35 first_tier_height=$(( (branches_total + 1) / 2 ))  
36 second_tier_height=$(( branches_total / 2 ))  
37  
38 width=1  
39 for ((i = 1; i <= first_tier_height; i++)); do  
40   if (( i % 2 == 1 )); then  
41     line_chars=$(printf '%*s' "$width" | tr ' ' '*')  
42   else  
43     line_chars=$(printf '%*s' "$width" | tr ' ' '#')  
44   fi  
45   print_centered_line "$snow_width" "$line_chars" "$width"  
46   width=$(( width + 2 ))  
47 done  
48  
49 width=3  
50 for ((j = 1; j <= second_tier_height; j++)); do  
51   if (( j % 2 == 1 )); then  
52     line_chars=$(printf '%*s' "$width" | tr ' ' '#')  
53   else  
54     line_chars=$(printf '%*s' "$width" | tr ' ' '*')  
55   fi  
56   print_centered_line "$snow_width" "$line_chars" "$width"  
57   width=$(( width + 2 ))  
58 done  
59  
60 for ((t = 0; t < 2; t++)); do  
61   print_centered_line "$snow_width" "###" "$trunk_width"  
62 done  
63  
64 snow_line=$(printf '%*s' "$snow_width" | tr ' ' '*')  
65 print_centered_line "$snow_width" "$snow_line" "$snow_width"  
